# Мотивация

## Декомпозиция, это не не просто

В наши дни компоненты становятся такими большими и вариативными. Обычно вариативность выражается через большое количество произвольных условий внутри кода в императивном стиле. Работать с таким кодом сложно:
- тяжело оценить всю возможную вариативность
- логика определенной функциональности может быть размазана по нескольким местам в коде, что усложняет расширение и изменение компонентов

Кроме того, среднестатистический метод `render` несет в себе основную часть логики компонента. Переносить/переопределять/доопределять такой код сложно, по причине того, что приходиться переписывать добрую часть метода.

Описание всего возможного поведения внутри одного компонента, в случае опциональной вариативности, неизбежно приведёт к загрузке лишнего кода в рантайм. Не существуют удобного пути "рассказать" системе сборки какие именно части кода надо подключать в конкретном случае.

## Повторное использование кода, это не просто

Компонентов становится много и они становятся достаточно сложными. Между ними появляется общий код. Хочется легко реиспользовать общие части. Сейчас есть два способа: классическое наследование и High Order Components.

С наследованием тяжело комбинировать несколько ортогональных признаков без полного перепроектирования иерархии классов. И вообще обладает целым рядом других проблем, о которых уже [не раз писали](https://en.wikipedia.org/wiki/Composition_over_inheritance).

В случае Hight Order Components, при композиции нескольких разных компонентов, отвечающих за разные аспекты функциональности, получается раздутие виртуального дерева и часто не обойтись без использования `React.cloneElement`.

## Кроссплатформенная разработка, это не просто

Современные веб-сервисы вынуждены разрабатываться как минимум для десктопов и мобильных. Есть два подхода:
- две (и более) отдельных версии сервиса для разных платформ
- одна адаптивная версия

Каждый из них обладает своими недостатками.

Несколько отдельных версий требуют больше усилий (пропорционально количеству версий) и обостряют проблемы со сложностью повторно использовать код. И даже если у вас достаточно ресурсов, чтобы иметь разные версии, дополнительная сложностью будет поддержание их в синхронном состоянии с точки зрения продуктовых свойств.

Разрабатывая одну адаптивную версию прийдётся учитывать, что один и тот же код будет исполняться на разных платформах. Это всё усложняет! Сложность кода и требования к квалификации разработчиков становятся выше. Часто такой код имеет ещё и проблемы с производительностью, особенно на мобильных устройствах.

## Эксперименты, это не просто

Чтобы успешно разрабатывать сервисы с большой аудиторией нужно быть уверенным в каждом изменении. A/B эксперименты, это один из способов получить такую уверенность.

Можно выделить два паттерна организации кода для проведения экспериментов:
- ветвление всей кодовой базы и создание отдельных экземпляров сервиса
- точечные условия внутри одной кодовой базы

Ветвление всей кодовой базы может вызвать существенные накладные расходы в случае большого количества долгоиграющих экспериментов, т.к. неизбежно придётся  синхронизировать изменения, например, багфиксы, продуктовую функциональность не требующую экспериментов и/или успешно их прошедшую. Кроме этого, становится сложно проводить пересекающиеся эксперименты.

С другой стороны, точечные условия внутри одной кодовой базы работают гибче, но ведут к усложнению кодовой базы. Большое количество условий затрудняет не только понимание кода для человека, но и ухудшает производительность (за счёт увеличения объёма кода для браузера). Кроме того, когда эксперимент завершился, то нужно избавиться от лишнего кода: убрать условия и сделать код основным или полностью удалить неудачный эксперимент. Т.к. код про один эксперимент может быть размазан по многим местам, а основная функциональность постоянно меняется, то это может быть не просто!

## Взаимодействие общей библиотеки компонентов и разных сервисов, это не просто


