# Мотивация

## Декомпозиция, это не не просто

В наши дни компоненты становятся такими большими и вариативными. Обычно вариативность выражается через большое количество произвольных условий внутри кода в императивном стиле. Работать с таким кодом сложно:
- тяжело оценить всю возможную вариативность
- логика определенной функциональности может быть размазана по нескольким местам в коде, что усложняет расширение и изменение компонентов

Кроме того, среднестатистический метод `render` несет в себе основную часть логики компонента. Переносить/переопределять/доопределять такой код сложно, по причине того, что приходиться переписывать добрую часть метода.

Описание всего возможного поведения внутри одного компонента, в случае опциональной вариативности, неизбежно приведёт к загрузке лишнего кода в рантайм. Не существуют удобного пути "рассказать" системе сборки какие именно части кода надо подключать в конкретном случае.

## Повторное использование кода, это не просто

Компонентов становится много и они становятся достаточно сложными. Между ними появляется общий код. Хочется легко реиспользовать общие части. Сейчас есть два способа: классическое наследование и High Order Components.

С наследованием тяжело комбинировать несколько ортогональных признаков без полного перепроектирования иерархии классов. И вообще обладает целым рядом других проблем, о которых уже [не раз писали](https://en.wikipedia.org/wiki/Composition_over_inheritance).

В случае Hight Order Components, при композиции нескольких разных компонентов, отвечающих за разные аспекты функциональности, получается раздутие виртуального дерева и часто не обойтись без использования `React.cloneElement`.